---
description:
globs:
alwaysApply: true
---
# API Call Patterns

This rule establishes consistent patterns for all client-to-backend API calls in the React application.

## Core Pattern Requirements

1. **Use the `fetchApi` utility:** Always use the `fetchApi` utility function from `src/utils/fetchApi.ts` for all API calls to maintain consistency in request formatting and error handling.

2. **Create dedicated hooks:** Encapsulate all API logic in custom hooks:
   - Place hooks in the `src/hooks` directory with a descriptive name (e.g., `use-files.ts`)
   - Follow the naming convention `use-{resource}.ts` for hook files
   - Export functions with names like `use{Resource}{Action}` (e.g., `useFilesList`, `useFileDelete`)

3. **Use React Query:** Leverage React Query for all API calls:
   - Use `useQuery` for GET requests
   - Use `useMutation` for POST/PUT/DELETE operations
   - Define appropriate `queryKey` values for caching
   - Handle loading states, errors, and success cases

## Correct Implementation Example

The `use-auth.tsx` file demonstrates the correct pattern:

```typescript
// Hook is defined separately from component
export function useAuth() {
  // Uses useQuery for data fetching
  const { data: queryData, refetch: refetchUserInternal } = useQuery({
    queryKey: ['authUser'],
    queryFn: async () => {
      // Uses fetchApi utility
      const res = await fetchApi('/auth/me');
      // Error handling, data processing
    }
  });
  
  // Additional methods encapsulated in the hook
  const signOut = useCallback(async () => {
    await fetchApi('/auth/signout');
    // Handle success, cleanup
  }, []);
  
  return { user, isLoading, signOut /* other values */ };
}
```

## Incorrect Pattern to Avoid

Avoid embedding API calls directly in components as seen in `src/routes/home/_layout/admin/files.tsx`:

```typescript
// ❌ AVOID: Direct API calls in component
async function fetchAdminFiles(): Promise<FileListItem[]> {
  const response = await fetch('/api/files/admin/list', {
    credentials: 'include',
  });
  // error handling
}

// ❌ AVOID: Component contains API logic
function AdminFilesPage() {
  const { data: files } = useQuery<FileListItem[], Error>({
    queryKey: ['adminFiles'],
    queryFn: fetchAdminFiles,
  });
}
```

## Corrected Pattern

Instead, create a dedicated hook for file operations:

```typescript
// src/hooks/use-files.ts
export function useAdminFilesList() {
  return useQuery<FileListItem[], Error>({
    queryKey: ['adminFiles'],
    queryFn: async () => {
      const response = await fetchApi('/files/admin/list');
      if (!response.ok) {
        const errorData = await response.json().catch(() => ({}));
        throw new Error(errorData.error || 'Erro ao buscar arquivos');
      }
      return response.json();
    }
  });
}

export function useAdminFileDelete() {
  const queryClient = useQueryClient();
  
  return useMutation<{ message: string }, Error, string>({
    mutationFn: async (objectName) => {
      const response = await fetchApi('/files/admin/delete', {
        method: 'POST',
        body: JSON.stringify({ objectName }),
      });
      if (!response.ok) {
        const errorData = await response.json().catch(() => ({}));
        throw new Error(errorData.error || 'Erro ao excluir arquivo');
      }
      return response.json();
    },
    onSuccess: () => {
      queryClient.invalidateQueries({ queryKey: ['adminFiles'] });
    }
  });
}
```

Then in your component:

```typescript
function AdminFilesPage() {
  const { data: files, isLoading, error } = useAdminFilesList();
  const { mutate: deleteFile, isPending: isDeleting } = useAdminFileDelete();
  
  // Component logic using the hooks
}
